# Easy (1–20)
* Print a linked list
* Find the length of a linked list
* Insert at head
* Insert at tail
* Delete a node by value
* Delete a node by position
* Reverse a linked list iteratively
* Reverse recursively
* Find the middle node (slow‑fast pointers)
* Find the nth node from end
* Detect a cycle (Floyd’s algorithm)
* Remove duplicates from sorted list
* Move last node to front
* Rotate list by k places
* Delete every k-th node
* Pairwise swap nodes
* Check if list is palindrome
* Print list in reverse order (using recursion stack)
* Delete “middle” node (no head access)
* Merge two sorted lists

# Medium (21–60)
* Reverse a doubly linked list
* Insert into sorted doubly linked list
* Circular list traversal
* Deletion in circular list
* Split list into two halves
* Swap kth node from ends
* Remove every alternate node
* Merge lists at alternate positions
* Segregate even/odd nodes (by value)
* Sort 0s,1s,2s in list
* Flatten linked list with random pointer
* Copy list with next & random pointers
* Reverse list in groups of size k
* Alternate k-group reversal
* Delete N nodes after M nodes
* Find intersection of two lists
* Remove node without head pointer
* Remove first occurrence of a value
* Remove all occurrences of a value
* Find pair with given sum
* Convert binary number in list to integer
* Compare two lists for equality
* Merge k sorted lists
* Flatten multi-level linked list
* Partition list around a value x
* Move negative numbers ahead of positives
* Rearrange list in-place (odd-even positions)
* Queue via singly linked list
* Stack via singly linked list
* Delete last occurrence of an item
* Check if list is circular
* Occurrence count of a key
* Print nodes at odd/even indices
* K-th node swap variants (start-end)
* Reverse display of doubly linked list
* Rotate doubly linked list
* Convert doubly linked list to BST
* Split circular list into two halves
* Reverse alternate k nodes in list
* Delete duplicates from unsorted doubly list


# Hard & Advanced (61–100)
* Add two numbers represented by linked lists
* Multiply two numbers in lists
* QuickSort a linked list
* Merge sort on a linked list
* Reverse in blocks of k (multiple passes)
* Cyclic path decomposition
* Clone list with random pointers
* Clone list with next & arbitrary pointers
* LRU cache implementation
* Delete N after M nodes repeatedly
* Smallest range covering k lists
* Construct list from 2D matrix (zigzag)
* Partition list dynamically
* Intersection point detection
* Detect & remove loop
* Rearrange list (specific patterns)
* Dynamic linked list partitioning
* Convert binary tree to doubly linked list
* Double-list flattening
* Rotate circular list by N nodes
* Block reversal variants
* Pointer-jumping for parallel speed-up
* List-ranking (distances to end)
* Implement iterator with O(1) remove
* Random pointer graph traversal
* Persistent linked list versioning
* Skip list implementation
* Flatten nested linked list
* Convert to skip list
* Evaluate polynomial via linked list
* Add very large integers via linked list
* Job scheduling list with priority
* Merge overlapping intervals in list
* Detect sublist patterns
* Remove zero-sum sublists
* Odd-even position mix
* Rotate merged multi-list
* Shuffle linked list uniformly
* Reservoir sampling over a list
* Multi-linked list (multi-key sort)